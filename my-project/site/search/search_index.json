{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to the easy-crypt documentation This is a simple library. You can use it to hash, encrypt and decrypt data. It allows easy use of the pychryptodome library. Old ciphers are also being added. ReadMe Chipher Old Chipher Hash Changelog Version = 0.0.2 Note: bold types are the standard ones","title":"Home"},{"location":"#welcome-to-the-easy-crypt-documentation","text":"This is a simple library. You can use it to hash, encrypt and decrypt data. It allows easy use of the pychryptodome library. Old ciphers are also being added. ReadMe Chipher Old Chipher Hash Changelog Version = 0.0.2 Note: bold types are the standard ones","title":"Welcome to the easy-crypt documentation"},{"location":"Changelog/","text":"easy-crypt Changelog Release 0.0.2: added old section -> added Caesar and Vigener cipher added pyprind support for Vigener and Caesar added Exceptions added docs to the functions added documentation at readthedocs Release 0.0.1: Feb 10, 2021 Symmetric and Asymmetric Encryption and Decryption Simple hash generating and comparing","title":"Changelog"},{"location":"Changelog/#easy-crypt-changelog","text":"","title":"easy-crypt Changelog"},{"location":"Changelog/#release-002","text":"added old section -> added Caesar and Vigener cipher added pyprind support for Vigener and Caesar added Exceptions added docs to the functions added documentation at readthedocs","title":"Release 0.0.2:"},{"location":"Changelog/#release-001-feb-10-2021","text":"Symmetric and Asymmetric Encryption and Decryption Simple hash generating and comparing","title":"Release 0.0.1: Feb 10, 2021"},{"location":"Cipher/","text":"Cipher Symmetric Encryption Use gen_sym_keys() to gain keys. You can use them to encrypt with encrypt_sym(text,key) or decrypt with decrypt_sym(text,key) from easy_crypt.cipher import cipher_funct as cf key = cf.gen_keys() encr = cf.encrypt_sym(\"I like easy_crypt\",key) # Output as bytes decr = cf.decrypt_sym(encr,key) # Output as str print(decr) # prints \"I like easy_crypt\" gen_sym_keys() can take 1 argument: get_sym_keys(bytes=32) :param bytes: (optional) length of the key :return: returns key (type: bytes ) encrypt_sym() takes 2 arguments: encrypt_sym(text, key) :param text: data that is supposed to be encrypted (type: str, hex or bytes) :param key: the key :return: returns decrypted data (type: bytes ) decrypt_sym() takes 2 arguments: decrypt_sym(text, key) :param text: data that is supposed to be decrypted (type: str, hex or bytes) :param key: the key (is the same one as the one used to encrypt) :return: returns decrypted data (type: bytes ) Asymmetrical Encryption Use gen_asym_keys() to gain the private key and public key. You can use the public key to encrypt with encrypt_asym(text,public_key) and the private key to decrypt with decrypt_asym(text,private_key) . Remember, you can only encrypt a limited byte size of data . from easy_crypt.cipher import cipher_funct as cf private_key, public_key = cf.gen_asym_keys() encr = cf.encrypt_asym(\"Test\",public_key) #The input type must be hex, string or bytes decr = cf.decrypt_asyn(encr,private_key) # Output as bytes print(decr.decode('utf-8')) get_asym_keys() can take 1 argument: gen_asym_keys(length=2048) :param length: (optional) length of the keys :return: returns private key, public key encrypt_asym() takes 2 arguments: encrypt_asym(text, pubkey) :param text: data that is supposed to be encrypted (type: str, hex or bytes) :param pubkey: public key :return: decrypted text (type: bytes ) decrypt_asym() takes 2 arguments: decrypt_asym(text, prkey) :param text: data that is supposed to be decrypted (type: bytes) :param prkey: privat key :return: decrypted text (type: bytes ) Combination of Both A combination results in being ably to encrypt an infinite amount of data and use private and public keys. Use encrypt_data() to encrypt data and decrypt_data() to decrypt data from easy_crypt.cipher import cipher_funct as cf private_key,public_key = cf.gen_asym_keys() encr = cf.encrypt_data(\"very long and importan message\",public_key) # #The input type must be hex, str or bytes decr = cf.decrypt_data(encr,private_key) # Output as str print(decr) #prints \"very long and importan message\" encrypt_data() can take 4 arguments: encr_data(data, pubkey, bytes=32, output=\"bytes\") :param data: the data that is supposed to be decrypted (type: hex, str or bytes) :param pubkey: public_key :param bytes: (optional) number of bytes of the symmetric key :param output: (optional) type of the output (bytes or hex) :return: returns encrypted data (type: bytes or hex) decrypt_data() can take 3 arguments: decr_data(data, prkey, output=\"str\") :param data: the data that is supposed to be decrypted (type: to str converted hex, hex or bytes) :param prkey: private_key :param output: (optional) type of the output (bytes, str ) :return: encrypted msg (type: str , bytes)","title":"Chipher"},{"location":"Cipher/#cipher","text":"","title":"Cipher"},{"location":"Cipher/#symmetric-encryption","text":"Use gen_sym_keys() to gain keys. You can use them to encrypt with encrypt_sym(text,key) or decrypt with decrypt_sym(text,key) from easy_crypt.cipher import cipher_funct as cf key = cf.gen_keys() encr = cf.encrypt_sym(\"I like easy_crypt\",key) # Output as bytes decr = cf.decrypt_sym(encr,key) # Output as str print(decr) # prints \"I like easy_crypt\" gen_sym_keys() can take 1 argument: get_sym_keys(bytes=32) :param bytes: (optional) length of the key :return: returns key (type: bytes ) encrypt_sym() takes 2 arguments: encrypt_sym(text, key) :param text: data that is supposed to be encrypted (type: str, hex or bytes) :param key: the key :return: returns decrypted data (type: bytes ) decrypt_sym() takes 2 arguments: decrypt_sym(text, key) :param text: data that is supposed to be decrypted (type: str, hex or bytes) :param key: the key (is the same one as the one used to encrypt) :return: returns decrypted data (type: bytes )","title":"Symmetric Encryption"},{"location":"Cipher/#asymmetrical-encryption","text":"Use gen_asym_keys() to gain the private key and public key. You can use the public key to encrypt with encrypt_asym(text,public_key) and the private key to decrypt with decrypt_asym(text,private_key) . Remember, you can only encrypt a limited byte size of data . from easy_crypt.cipher import cipher_funct as cf private_key, public_key = cf.gen_asym_keys() encr = cf.encrypt_asym(\"Test\",public_key) #The input type must be hex, string or bytes decr = cf.decrypt_asyn(encr,private_key) # Output as bytes print(decr.decode('utf-8')) get_asym_keys() can take 1 argument: gen_asym_keys(length=2048) :param length: (optional) length of the keys :return: returns private key, public key encrypt_asym() takes 2 arguments: encrypt_asym(text, pubkey) :param text: data that is supposed to be encrypted (type: str, hex or bytes) :param pubkey: public key :return: decrypted text (type: bytes ) decrypt_asym() takes 2 arguments: decrypt_asym(text, prkey) :param text: data that is supposed to be decrypted (type: bytes) :param prkey: privat key :return: decrypted text (type: bytes )","title":"Asymmetrical Encryption"},{"location":"Cipher/#combination-of-both","text":"A combination results in being ably to encrypt an infinite amount of data and use private and public keys. Use encrypt_data() to encrypt data and decrypt_data() to decrypt data from easy_crypt.cipher import cipher_funct as cf private_key,public_key = cf.gen_asym_keys() encr = cf.encrypt_data(\"very long and importan message\",public_key) # #The input type must be hex, str or bytes decr = cf.decrypt_data(encr,private_key) # Output as str print(decr) #prints \"very long and importan message\" encrypt_data() can take 4 arguments: encr_data(data, pubkey, bytes=32, output=\"bytes\") :param data: the data that is supposed to be decrypted (type: hex, str or bytes) :param pubkey: public_key :param bytes: (optional) number of bytes of the symmetric key :param output: (optional) type of the output (bytes or hex) :return: returns encrypted data (type: bytes or hex) decrypt_data() can take 3 arguments: decr_data(data, prkey, output=\"str\") :param data: the data that is supposed to be decrypted (type: to str converted hex, hex or bytes) :param prkey: private_key :param output: (optional) type of the output (bytes, str ) :return: encrypted msg (type: str , bytes)","title":"Combination of Both"},{"location":"Hash/","text":"Hash Generating a Hash Use the gen-hash() function to create a hash. The input type should be bytes or str. from easycrypt.hash.hash_funct import gen_hash pw = \"Test\" hash = gen_hash(pw) #output in hex The gen_hash() function can take 5 arguments: gen_hash(text, predefined_salt=None, hash_type='sha512', iterations=100000, data_type='hex') :param text: the text that is supposed to be hashed (type: bytes, bytearray, str or hex) :param predefined_salt: (optional) specific salt that should be used :param hash_type: (optional) defines what hash algorithm should be used :param iterations: (optional) defines the amount of iterations :param data_type: (optional) defines the output type; hex and bytes are available :return: returns hash (type: hex or bytes) Comparing a Hash Use compare_hash() to compare a text to a hash. hash = 'df70b9c795527ee3efcf3b0f36e669307d98895d402bd3c34dd7bd92222bdb8fde4e04ac169b9f27e1327e87e7e337b93d65c858a08fce7f3d1624e7fdb692807957b496801e5621b0f949f96d5811ff27125b9f866da3eaf9197f15703d335e' to_compare = \"Test\" print(compare_hash(pw,hash)) # prints \"True\" This function can take 4 arguments: compare_hash(to_compare, hash, hash_type='sh512', iterations=100000) :param to_compare: the text that should be compared with the hash (type:hex, to str converted hex or bytes) :param hash: the hash that should be compared with the text :param hash_type: (optional) defines what hash algorithm should be used :param iterations: (optional) defines the amount of iterations :return: returns True or False (type: bool)","title":"Hash"},{"location":"Hash/#hash","text":"","title":"Hash"},{"location":"Hash/#generating-a-hash","text":"Use the gen-hash() function to create a hash. The input type should be bytes or str. from easycrypt.hash.hash_funct import gen_hash pw = \"Test\" hash = gen_hash(pw) #output in hex The gen_hash() function can take 5 arguments: gen_hash(text, predefined_salt=None, hash_type='sha512', iterations=100000, data_type='hex') :param text: the text that is supposed to be hashed (type: bytes, bytearray, str or hex) :param predefined_salt: (optional) specific salt that should be used :param hash_type: (optional) defines what hash algorithm should be used :param iterations: (optional) defines the amount of iterations :param data_type: (optional) defines the output type; hex and bytes are available :return: returns hash (type: hex or bytes)","title":"Generating a Hash"},{"location":"Hash/#comparing-a-hash","text":"Use compare_hash() to compare a text to a hash. hash = 'df70b9c795527ee3efcf3b0f36e669307d98895d402bd3c34dd7bd92222bdb8fde4e04ac169b9f27e1327e87e7e337b93d65c858a08fce7f3d1624e7fdb692807957b496801e5621b0f949f96d5811ff27125b9f866da3eaf9197f15703d335e' to_compare = \"Test\" print(compare_hash(pw,hash)) # prints \"True\" This function can take 4 arguments: compare_hash(to_compare, hash, hash_type='sh512', iterations=100000) :param to_compare: the text that should be compared with the hash (type:hex, to str converted hex or bytes) :param hash: the hash that should be compared with the text :param hash_type: (optional) defines what hash algorithm should be used :param iterations: (optional) defines the amount of iterations :return: returns True or False (type: bool)","title":"Comparing a Hash"},{"location":"basic_info/","text":"Project Description This is a simple library. You can use it to hash, encrypt and decrypt data. It allows easy use of the pychryptodome library. You can securely encrypt any msg of any length with encrypt_data(text,public_key). It uses asymmetric and symmetric encryption: from easycrypt.cipher.cypherfunct import encrypt_data,decrypt_data,gen_asym_keys private_key,public_key = gen_asym_keys() msg = \"Hello World\" encrypted_msg = encrypt_data(msg,public_key) # output in bytes #Now it is encrypted decrypted_msg = decrypt_data(encrypted_msg, private_key) # output in bytes print(decrypted_msg) # prints \"Hello World\" And of course decrypt it. If you want to store passwords securely, you can use the gen_hash(text) function to create and the compare_hash(text,hash) to compare them from easycrypt.hash.hash_funct import gen_hash, compare_hash pw = \"Hello Hash\" hash = gen_hash(pw) #output in hex to_compare = \"Hello Hash\" print(compare_hash(pw,hash)) # prints \"True\"; The output is a boolean You can use old ciphers too, like Vigener or Caesar.","title":"ReadMe"},{"location":"basic_info/#project-description","text":"This is a simple library. You can use it to hash, encrypt and decrypt data. It allows easy use of the pychryptodome library. You can securely encrypt any msg of any length with encrypt_data(text,public_key). It uses asymmetric and symmetric encryption: from easycrypt.cipher.cypherfunct import encrypt_data,decrypt_data,gen_asym_keys private_key,public_key = gen_asym_keys() msg = \"Hello World\" encrypted_msg = encrypt_data(msg,public_key) # output in bytes #Now it is encrypted decrypted_msg = decrypt_data(encrypted_msg, private_key) # output in bytes print(decrypted_msg) # prints \"Hello World\" And of course decrypt it. If you want to store passwords securely, you can use the gen_hash(text) function to create and the compare_hash(text,hash) to compare them from easycrypt.hash.hash_funct import gen_hash, compare_hash pw = \"Hello Hash\" hash = gen_hash(pw) #output in hex to_compare = \"Hello Hash\" print(compare_hash(pw,hash)) # prints \"True\"; The output is a boolean You can use old ciphers too, like Vigener or Caesar.","title":"Project Description"},{"location":"old_chipher/","text":"Old Chiphers This section talks about every chipher under the easy_crypt.cipher.old section Caesar This Cipher supports pyprind The standard alphabet is: standard_alphabet = string.ascii_lowercase + string.ascii_uppercase + \" \" + string.punctuation + string.digits + \"\u00c4\u00d6\u00dc\u00e4\u00f6\u00fc\u00df\u00c3\u0178\u00e2\u2026\u00a4\u20ac\" from easy_crypt.chipher.old import caeser as c encr = c.encrypt(\"Hello\",5) #Shift 5 print(encr) #prints \"Mjqqt\" decr = c.decrypt(encr,5) #Shift 5 back print(decr) #prints \"Hello\" If you want to use pyprind, do it like this: from easy_crypt.chipher.old import caeser as c encr,bar = c.encrypt(\"Hello\",5,progbar=True) #Shift 5 print(bar) # prints final bar; this isn't needed print(encr) #prints \"Mjqqt\" decr,bar = c.decrypt(encr,5,progbar=True) #Shift 5 back print(bar) # prints final bar; this isn't needed print(decr) #prints \"Hello\" encrypt() can take 4 arguments: encrypt(text, shift, alphabet=None, progbar=False) :param text: The text that is supposed to be encrypted (type: str ) :param shift: The Change of the text (type: int ) :param alphabet: The used Alphabet for encryption (type: str ) :param progbar: If the pyprind library should be used (type: bool ) :return: The encrypted text (type: str ) decrypt() can take 4 arguments: decrypt(text, shift, alphabet=None, progbar=False) :param text: The text that is supposed to be decrypted (type: str ) :param shift: The Change of the text (type: int ) :param alphabet: alphabet: The used Alphabet for decryption (type: str ) :param progbar: bool: If the pyprind library should be used (type: bool ) :return: The decrypted text (type: str ) Vigener This Cipher supports pyprind The standard alphabet is: standard_alphabet = string.ascii_lowercase + string.ascii_uppercase + \" \" + string.punctuation + string.digits + \"\u00c4\u00d6\u00dc\u00e4\u00f6\u00fc\u00df\u00c3\u0178\u00e2\u2026\u00a4\u20ac\" from easy_crypt.chipher.old import vigener as v encr = v.encrypt(\"Hello\",\"Hello\") #Encrypts with the pw print(encr) #prints \".iwwC\" decr = c.decrypt(encr,\"Hello\") #Decrypts with the pw print(decr) #prints \"Hello\" If you want to use pyprind, do it like this: from easy_crypt.chipher.old import vigener as v encr, bar = v.encrypt(\"Hello\",\"Hello\",progbar=True) #Encrypts with the pw print(bar) # prints final bar; this isn't needed print(encr) #prints \".iwwC\" decr,bar = c.decrypt(encr,\"Hello\",progbar=True) #Decrypts with the pw print(bar) # prints final bar; this isn't needed print(decr) #prints \"Hello\" encrypt() can take 4 arguments: encrypt(text, pw, alphabet=None, progbar=False) :param text: The text that is supposed to be encrypted (type: str ) :param pw: The password for the encryption (type: str ) :param alphabet: The used Alphabet for encryption (type: str ) :param progbar: bool: If the pyprind library should be used (type: bool ) :return: The encrypted text (type: str ) decrypt() can take 4 arguments: decrypt(text, pw, alphabet=None, progbar=False) :param text: The text that is supposed to be decrypted (type: str ) :param pw: The password for the decryption (type: str ) :param alphabet: The used Alphabet for encryption (type: str ) :param progbar: bool: If the pyprind library should be used (type: bool ) :return: The decrypted text (type: str )","title":"Old Chipher"},{"location":"old_chipher/#old-chiphers","text":"This section talks about every chipher under the easy_crypt.cipher.old section","title":"Old Chiphers"},{"location":"old_chipher/#caesar","text":"This Cipher supports pyprind The standard alphabet is: standard_alphabet = string.ascii_lowercase + string.ascii_uppercase + \" \" + string.punctuation + string.digits + \"\u00c4\u00d6\u00dc\u00e4\u00f6\u00fc\u00df\u00c3\u0178\u00e2\u2026\u00a4\u20ac\" from easy_crypt.chipher.old import caeser as c encr = c.encrypt(\"Hello\",5) #Shift 5 print(encr) #prints \"Mjqqt\" decr = c.decrypt(encr,5) #Shift 5 back print(decr) #prints \"Hello\" If you want to use pyprind, do it like this: from easy_crypt.chipher.old import caeser as c encr,bar = c.encrypt(\"Hello\",5,progbar=True) #Shift 5 print(bar) # prints final bar; this isn't needed print(encr) #prints \"Mjqqt\" decr,bar = c.decrypt(encr,5,progbar=True) #Shift 5 back print(bar) # prints final bar; this isn't needed print(decr) #prints \"Hello\" encrypt() can take 4 arguments: encrypt(text, shift, alphabet=None, progbar=False) :param text: The text that is supposed to be encrypted (type: str ) :param shift: The Change of the text (type: int ) :param alphabet: The used Alphabet for encryption (type: str ) :param progbar: If the pyprind library should be used (type: bool ) :return: The encrypted text (type: str ) decrypt() can take 4 arguments: decrypt(text, shift, alphabet=None, progbar=False) :param text: The text that is supposed to be decrypted (type: str ) :param shift: The Change of the text (type: int ) :param alphabet: alphabet: The used Alphabet for decryption (type: str ) :param progbar: bool: If the pyprind library should be used (type: bool ) :return: The decrypted text (type: str )","title":"Caesar"},{"location":"old_chipher/#vigener","text":"This Cipher supports pyprind The standard alphabet is: standard_alphabet = string.ascii_lowercase + string.ascii_uppercase + \" \" + string.punctuation + string.digits + \"\u00c4\u00d6\u00dc\u00e4\u00f6\u00fc\u00df\u00c3\u0178\u00e2\u2026\u00a4\u20ac\" from easy_crypt.chipher.old import vigener as v encr = v.encrypt(\"Hello\",\"Hello\") #Encrypts with the pw print(encr) #prints \".iwwC\" decr = c.decrypt(encr,\"Hello\") #Decrypts with the pw print(decr) #prints \"Hello\" If you want to use pyprind, do it like this: from easy_crypt.chipher.old import vigener as v encr, bar = v.encrypt(\"Hello\",\"Hello\",progbar=True) #Encrypts with the pw print(bar) # prints final bar; this isn't needed print(encr) #prints \".iwwC\" decr,bar = c.decrypt(encr,\"Hello\",progbar=True) #Decrypts with the pw print(bar) # prints final bar; this isn't needed print(decr) #prints \"Hello\" encrypt() can take 4 arguments: encrypt(text, pw, alphabet=None, progbar=False) :param text: The text that is supposed to be encrypted (type: str ) :param pw: The password for the encryption (type: str ) :param alphabet: The used Alphabet for encryption (type: str ) :param progbar: bool: If the pyprind library should be used (type: bool ) :return: The encrypted text (type: str ) decrypt() can take 4 arguments: decrypt(text, pw, alphabet=None, progbar=False) :param text: The text that is supposed to be decrypted (type: str ) :param pw: The password for the decryption (type: str ) :param alphabet: The used Alphabet for encryption (type: str ) :param progbar: bool: If the pyprind library should be used (type: bool ) :return: The decrypted text (type: str )","title":"Vigener"}]}